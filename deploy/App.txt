<!DOCTYPE html>
<html>
<head>
    <title>Progress by Hours</title>
    <!--  (c) 2015 Rally Software Development Corp.  All Rights Reserved. -->
    <!--  Build Date: Wed Feb 18 2015 16:42:16 GMT-0800 (PST) -->
    
    <script type="text/javascript">
        var APP_BUILD_DATE = "Wed Feb 18 2015 16:42:16 GMT-0800 (PST)";
        var CHECKSUM = 64041635105;
    </script>
    
    <script type="text/javascript" src="/apps/2.0rc3/sdk.js"></script>

    <script type="text/javascript">
        Rally.onReady(function() {
             
/**
 * A link that pops up a version dialog box
 */

Ext.define('Rally.technicalservices.InfoLink',{
    extend: 'Ext.Component',
    alias: 'widget.tsinfolink',
    
    /**
     * @cfg {String} informationHtml
     * Additional text to be displayed on the popup dialog (for exmaple,
     * to add a description of the app's use or functionality)
     */
    informationHtml: null,
    
    /**
     * 
     * cfg {String} title
     * The title for the dialog box
     */
     title: "Build Information",
    
    renderTpl: "<div id='{id}-infolinkWrap' class='tsinfolink'>i</div>",

    initComponent: function() {
        this.callParent(arguments);
       
    },
    
    onRender: function() {
        this.callParent(arguments);
        this.mon(this.el,'click',this.onClick,this);
    },
    _generateChecksum: function(string){
        var chk = 0x12345678,
            i;
        string = string.replace(/var CHECKSUM = .*;/,"");
        string = string.replace(/\s/g,"");  //Remove all whitespace from the string.
        
        for (i = 0; i < string.length; i++) {
            chk += (string.charCodeAt(i) * i);
        }
    
        return chk;
    },
    _checkChecksum: function(container) {
        var me = this;
        Ext.Ajax.request({
            url: document.URL,
            params: {
                id: 1
            },
            success: function (response) {
                text = response.responseText;
                if ( CHECKSUM ) {
                    if ( CHECKSUM !== me._generateChecksum(text) ) {
                        console.log("Checksums don't match!");
                        if ( me.dialog ) {
                            me.dialog.add({xtype:'container',html:'Checksums do not match'});
                        }
                    }
                }
            }
        });
    },
    onClick: function(e) {
        var me = this;
        this._checkChecksum(this);
        
        var dialog_items = [];
        
        if ( this.informationHtml ) {
            dialog_items.push({
                xtype:'container',
                html: this.informationHtml
            });
        }
                
        dialog_items.push({
            xtype:'container',
            html:"This app was created by the Rally Technical Services Team."
        });
        
        if ( APP_BUILD_DATE ) {
            dialog_items.push({
                xtype:'container',
                html:'Build date/time: ' + APP_BUILD_DATE
            });
        }
        
        if (this.dialog){this.dialog.destroy();}
        this.dialog = Ext.create('Rally.ui.dialog.Dialog',{
            defaults: { padding: 5, margin: 5 },
            closable: true,
            draggable: true,
            title: me.title,
            items: dialog_items
        });
        this.dialog.show();
    }
});

/*
 */
Ext.define('Rally.technicalservices.Logger',{
    constructor: function(config){
        Ext.apply(this,config);
    },
    log: function(args){
        var timestamp = "[ " + Ext.util.Format.date(new Date(), "Y-m-d H:i:s.u") + " ]";
        //var output_args = arguments;
        //output_args.unshift( [ "[ " + timestamp + " ]" ] );
        //output_args = Ext.Array.push(output_args,arguments);
        
        var output_args = [];
        output_args = Ext.Array.push(output_args,[timestamp]);
        output_args = Ext.Array.push(output_args, Ext.Array.slice(arguments,0));

        window.console && console.log.apply(console,output_args);
    }

});

/*
 * A series of utilities to help construct trees
 * with data gotten bottom or middle-up
 * 
 */
 
Ext.define('Rally.technicalservices.util.TreeBuilding', {
    singleton: true,
    logger: new Rally.technicalservices.Logger(),
    /*
     * Given a hash of models (key = object id) that all know what
     * their parent is (based on the "parent" field -- note lowercase)
     * Return an array of models that are at the root level and
     * have a "children" field (note lowercase)
     * with appropriate items in an array 
     */
    constructRootItems:function(item_hash) {
        var root_array = [];
        Ext.Object.each(item_hash, function(oid,item){
            if ( !item.get('children') ) { item.set('children',[]); }
            var direct_parent = item.get('parent');
            if (!direct_parent && !Ext.Array.contains(root_array,item)) {
                root_array.push(item);
            } else {
                
                var parent_oid =  direct_parent.ObjectID || direct_parent.get('ObjectID');
                if (!item_hash[parent_oid]) {
                    this.logger.log("Saved parent missing: ", parent_oid);
                    if ( !Ext.Array.contains(root_array,item) ) {
                        root_array.push(item);
                    }
                } else {
                    var parent = item_hash[parent_oid];
                    if ( !parent.get('children') ) { parent.set('children',[]); }
                    var kids = parent.get('children');
                    kids.push(item);
                    parent.set('children',kids);
                }
            }
        },this);
        return root_array;
    },
    /*
     * Given a hash of hashes (key = object id) that all know what
     * their parent is (based on the "parent" field -- note lowercase)
     * Return an array of models that are at the root level and
     * have a "children" field (note lowercase)
     * with appropriate items in an array 
     */
    constructRootItemsFromHashes:function(item_hash) {
        var root_array = [];
        Ext.Object.each(item_hash, function(oid,item){
            if ( !item.children ) { item.children = []; }
            var direct_parent = item.parent;
            if (!direct_parent && !Ext.Array.contains(root_array,item)) {
                root_array.push(item);
            } else {
                
                var parent_oid =  direct_parent.ObjectID;
                if (!item_hash[parent_oid]) {
                    this.logger.log("Saved parent missing: ", parent_oid);
                    if ( !Ext.Array.contains(root_array,item) ) {
                        root_array.push(item);
                    }
                } else {
                    var parent = item_hash[parent_oid];
                    if ( !parent.children ) { parent.children = []; }
                    var kids = parent.children;
                    kids.push(item);
                    parent.children = kids;
                }
            }
        },this);
        return root_array;
    },
    /**
     * Given an array of models, turn them into hashes
     */
    convertModelsToHashes: function(model_array) {
        var hash_array = [];
        Ext.Array.each(model_array,function(model){
            if (this.isModel(model)) {
                var model_as_hash = model.data;
                model_as_hash.expanded = false;
                model_as_hash.leaf = false;
                
                // children & parent are fields that are not a 
                // part of the model def'n so getData doesn't provide them
                if ( model.get('children') ) {
                    model_as_hash.children = this.convertModelsToHashes(model.get('children'));
                }
                if ( model.get('parent') ) {
                    if ( this.isModel(model.get('parent') ) ) {
                        model_as_hash.parent = model.get('parent').getData();
                    } else {
                        model_as_hash.parent = model.get('parent');
                    }
                }

                if (!model_as_hash.children || model_as_hash.children.length === 0 ) {
                    model_as_hash.leaf = true;
                }
                
                hash_array.push(model_as_hash);
            } else {
                hash_array.push(model);
            }
        },this);
        return hash_array;
    },
    isModel: function(model){
        return model && ( model instanceof Ext.data.Model );
    },
    /**
     * Given an array of top-level models (will have field called 'children' holding more models),
     * roll up the value in the bottom of the tree's field_name
     * 
     * Config object has these values:
     * 
     * @param [{Ext.data.model}] root_items
     * @param {String} field_name
     * @param {Boolean} leaves_only (true to ignore parent value, false to add children to parent's existing value)
     * @param {String|fn} calculator [ 'count' ]
     */
    rollup: function(config){
        Ext.Array.each(config.root_items,function(root_item){
            this._setValueFromChildren(root_item,config.field_name,config.calculator,config.leaves_only);
        },this);
        return config.root_items;
    },
    _setValueFromChildren:function(parent_item,field_name,calculator,leaves_only){
        var parent_value = parent_item.get(field_name) || 0;
        if ( calculator ) {
            parent_value = this._calculate(parent_item,calculator);
        }
        var children = parent_item.get('children') || [];
        
        if ( leaves_only && children.length > 0 ) { parent_value = 0; }

        Ext.Array.each(children,function(child_item) {
            this._setValueFromChildren(child_item,field_name,calculator,leaves_only);
            var child_value = child_item.get(field_name) || 0;
            if ( calculator && child_value == 0 ) {
                child_value = this._calculate(child_item,calculator);
            }
            parent_value += child_value;
        },this);
        parent_item.set(field_name,parent_value);
        return;
    },
    _calculate:function(item,calculator){
        'use strict';
        if ( calculator == 'count' ) {
            return 1;
        }
        return calculator(item);
        
    },
    /**
     * Given an array of root items, find nodes in the tree where field_name contains field_value
     * and prune them
     * 
     * @param {} root_items
     * @param {} field_name
     * @param {} field_value
     * @return {}
     */
    pruneByFieldValue: function(root_items,field_name,field_value){
        Ext.Array.each(root_items,function(root_item){
            this._removeByFieldValue(root_items,root_item,field_name,field_value);
        },this);
        return root_items;
    },
    _removeByFieldValue: function(parent_array,parent_item,field_name,field_value){
        var tester = new RegExp(field_value);
        
        if ( parent_item ) {
            var value = parent_item.get(field_name) || "";
            if ( tester.test(value) ) {
                Ext.Array.remove(parent_array,parent_item);
            } else {
                var kids = parent_item.get('children') || [];
                if ( kids.length > 0 ) {
                    Ext.Array.each(kids, function(kid){
                        this._removeByFieldValue(kids,kid,field_name,field_value);
                    },this);
                }
            }
        }
    }
});
/*
 * Most of our trees are generated top-down, which
 * is most performant; however, sometimes we need to
 * point to a set of items in the middle of a tree and
 * (to apply scope or query) and then construct the
 * tree above and below the found items
 * 
 * A good example of this is wanting to see all
 * the PIs that have a story in a particular iteration
 * or in a particular team.  The PIs won't be assigned
 * to an iteration and might not be in the chosen project
 * scope, so first we have to find the iteration-tied stories
 * and then go up and down the tree to make context appear.
 * 
 * 
 */
 
 Ext.define('Rally.technicalservices.InsideOutTree', {
    extend: 'Ext.container.Container',
    alias: 'widget.insideouttree',
    requires: [ 'Rally.technicalservices.Logger', 'Rally.technicalservices.util.TreeBuilding'],
    logger: new Rally.technicalservices.Logger(),
    columns: [],
    cls: 'rally-grid',
    /**
     * @cfg {String} targetQuery
     * 
     * WSAPI query to be applied at the target level
     * 
     */
    targetQuery: '(ObjectID > 0)',
    /**
     * @cfg {String} targetType
     * 
     * Model type path that the query and scope will be applied to (and the tree built from)
     * 
     */
    targetType: 'HierarchicalRequirement',
    /**
     * 
     * @type Number targetChunk
     * 
     * When searching for parents of the target type, we pass along an array of
     * ObjectIDs (so it's not one call per item and we get fewer calls to the server), 
     * but the length of that get is limited.  Instead of calculating the best length,
     * we just define a number of OIDs to shove into the call
     */
    targetChunk: 125,
    /**
     * @cfg {Boolean} treeScopeDown
     * 
     * True to include searching for children and other descendants
     */
    treeScopeDown: true,
    /**
     * @cfg {Boolean} treeScopeUp
     * 
     * True to include searching for parents and other ancestors
     */
    treeScopeUp: true,

    pruneFieldName: null,
    pruneFieldValue: null,
    
    initComponent: function() {
        if ( this.columns.length == 0 ) { throw("Missing required setting: columns"); }
        
        this.callParent();
        this.addEvents(
            /**
             * @event aftertree
             * Fires when the tree has been created and placed on the page.
             * @param {Rally.technicalservices.InsideOutTree} this
             * @param {Ext.tree.Panel} tree
             */
            'aftertree',
            /**
             * @event afterloadtargets
             * Fires when data has been collected from the initial target query
             * @param {Rally.technicalservices.InsideOutTree} this
             */
            'afterloadtargets',
            /**
             * @event afterload
             * Fires when data has been collected from the parents and children
             * @param {Rally.technicalservices.InsideOutTree} this
             */
            'afterload'
         );
    },
    initItems: function() {
        this.callParent();
        this._fetchPortfolioNames().then({
            scope: this,
            success: function(pi_model_names){
                this.logger.log("Portfolio Item Names: ",pi_model_names);
                this._gatherData().then({
                    scope: this,
                    success:function(all_unordered_items){
                        this.fireEvent('afterload',this);

                        var ordered_items = Rally.technicalservices.util.TreeBuilding.constructRootItems(all_unordered_items);
                        
                        if ( this.pruneFieldName && this.pruneFieldValue ) {
                            ordered_items = Rally.technicalservices.util.TreeBuilding.pruneByFieldValue(ordered_items, this.pruneFieldName, this.pruneFieldValue);
                        }
                        
                        var calculated_items = this._doColumnCalculations(ordered_items);

                        var ordered_items_as_hashes = Rally.technicalservices.util.TreeBuilding.convertModelsToHashes(calculated_items);
                        
                        this._makeStoreAndShowGrid(ordered_items_as_hashes);
                    },
                    failure:function(error_msg){ 
                        this.fireEvent('aftertree',this);
                        this.add({xtype:'container',html:error_msg}); 
                    }
                });
            },
            failure: function(error_msg){
                this.fireEvent('aftertree',this);
                this.add({xtype:'container',html:error_msg}); 
            }
        });
    },
    _gatherData:function(){
        var deferred = Ext.create('Deft.Deferred');
        this._fetchTargetItems().then({
            scope: this,
            success:function(target_items){
                var fetched_items_by_oid = {};
                Ext.Array.each(target_items,function(item){
                    fetched_items_by_oid[item.get('ObjectID')] = item;
                });
                this.fireEvent('afterloadtargets',this);
                var promises = [];
                
                if ( this.treeScopeDown ) {
                    promises.push(this._fetchChildItems(target_items,fetched_items_by_oid));
                }
                
                if ( this.treeScopeUp ) {
                    promises.push(this._fetchParentItems(target_items,fetched_items_by_oid));
                }
                
                Deft.Promise.all(promises).then({
                    scope: this,
                    success: function(all_unordered_items){
                        var flattened_array = Ext.Array.flatten(all_unordered_items);
                        
                        var all_unordered_items_hash = {};
                        if ( flattened_array.length > 0 ) {
                            all_unordered_items_hash = flattened_array[0];
                        }
                        deferred.resolve(all_unordered_items_hash);
                    },
                    failure: function(error_msg) { deferred.reject(error_msg); }
                });
            },
            failure:function(error_msg){ deferred.reject(error_msg); }
        });
        return deferred;
    },
    // The target items are items at the starting level -- query and scope applies
    _fetchTargetItems: function(){
        var deferred = Ext.create('Deft.Deferred');

        var query = '( ObjectID > 0 )';
        
        if ( this.targetQuery ){
            query = this.targetQuery;
        }
        
        var filters = null;
        if ( query instanceof Rally.data.wsapi.Filter ) {
            filters = query;
        } else {
            try {
                var filters = Rally.data.wsapi.Filter.fromQueryString(query);
            } catch(e) {
                deferred.reject("Filter is poorly constructed");
            }
        }
        
        Ext.create('Rally.data.wsapi.Store', {
            autoLoad: true,
            model: this.targetType,
            fetch: this._getFetchNames(),
            filters:filters,
            limit:'Infinity',
            listeners:  {
                scope: this,
                load: function(store, records, success){
                    if (success) {
                        deferred.resolve(records);
                    } else {
                        deferred.reject('Error loading ' + this.targetType + ' items');
                    }
               }
           }
        });
        return deferred.promise;
    },
    _fetchChildItems: function(parent_items,fetched_items, deferred){
        this.logger.log('_fetchChildItems',parent_items.length);
        if ( !deferred ) {
            deferred = Ext.create('Deft.Deferred');
        }
        
        var parent_oids = [];
        
        var promises = [];
        
        Ext.Object.each(parent_items,function(oid,parent){
            var type = parent.get('_type');
            var children_fields = this._getChildrenFieldsFor(type);
            
            if ( type == "testcase" ) {
                parent_oids.push(parent.get('ObjectID'));
            }
            
            if ( children_fields ) {
                Ext.Array.each(children_fields,function(children_field) {
                    promises.push(this._fetchCollection(parent,children_field));
                },this);
            }
        },this);
        
        if ( parent_oids.length > 0 ) {
            var number_of_oids = parent_oids.length;
            if (number_of_oids > 0 ) {
                for ( var i=0; i<number_of_oids; i+=this.targetChunk ) {
                    var chunk_array = parent_oids.slice(i,i+this.targetChunk);
                    promises.push(this._fetchByArrayOfValues('defect',chunk_array,"TestCase.ObjectID"));
                }
            }
            
        }
            
        if (promises.length > 0) {
            Deft.Promise.all(promises).then({
                scope: this,
                success: function(results) {
                    var children = Ext.Array.flatten(results);
                    Ext.Array.each(children,function(child){
                        if ( !fetched_items[child.get('ObjectID') ] ) {
                            var parent = this._getParentFrom(child);
                            fetched_items[child.get('ObjectID')] = child;
                        }
                    },this);
                    this._fetchChildItems(children,fetched_items,deferred);
                },
                failure: function(error_msg){ deferred.reject(error_msg); }
            });
        } else {
            this.logger.log("resolving _fetchChildItems");
            deferred.resolve(fetched_items);
        }
        return deferred.promise;
    },
    _fetchChildrenForParent:function(child_type,parent) {
        var connection_field = this._getAssociationFieldFor(child_type,parent.get('_type'));
        var filters = [{
            property:connection_field + ".ObjectID",
            value: parent.get('ObjectID')
        }];
        
        var deferred = Ext.create('Deft.Deferred');
        Ext.create('Rally.data.wsapi.Store', {
            autoLoad: true,
            model: child_type,
            fetch: this._getFetchNames(),
            filters: filters,
            context: {
                project: null
            },
            listeners:  {
                scope: this,
                load: function(store, records, success){
                    if (success) {
                        deferred.resolve(records);
                    } else {
                        deferred.reject('Error loading ' + model_name + ' items');
                    }
               }
           }
        });
        return deferred.promise;
    },
    _fetchCollection: function(parent,children_field){
        var deferred = Ext.create('Deft.Deferred');
        this.logger.log("_fetchCollection",children_field);
        
        var fields_to_fetch = this._getFetchNames();
        
        if ( parent.get(children_field)){
            parent.getCollection(children_field,{
                autoLoad: true,
                fetch: fields_to_fetch,
                listeners: {
                    scope: this,
                    load: function(store,records,success){
                        if ( success ) {
                            deferred.resolve(records);
                        } else {
                            deferred.reject("Problem fetching collection ", children_field);
                        }
                    }
                }
            });
        } else {
            deferred.resolve([]);
        }
        return deferred.promise;
    },
    _fetchParentItems: function(child_items,fetched_items, deferred){
        if ( !deferred ) {
            deferred = Ext.create('Deft.Deferred');
        }
        this.logger.log('fetched_items:',fetched_items);
        var fetched_oids = Ext.Object.getKeys(fetched_items);
        
        var parents_by_type = {};
        
        Ext.Array.each(child_items,function(child){
            var parent = this._getParentFrom(child);
            if ( parent ) {
                var parent_type = parent._type;
                var parent_oid = parent.ObjectID;
                if ( !parents_by_type[parent_type] ) { parents_by_type[parent_type] = []; }
                // don't look for parents more than once
                if ( !Ext.Array.contains(parents_by_type[parent_type], parent_oid) ){
                    if ( !Ext.Array.contains(fetched_oids, parent_oid) ) {
                        parents_by_type[parent_type].push(parent_oid);
                    }
                }
            }
        },this);
        
        var promises = [];
        Ext.Object.each(parents_by_type,function(type,oids){
            var number_of_oids = oids.length;
            if (number_of_oids > 0 ) {
                for ( var i=0; i<number_of_oids; i+=this.targetChunk ) {
                    var chunk_array = oids.slice(i,i+this.targetChunk);
                    promises.push(this._fetchItemsByOIDArray(type,chunk_array));
                }
            }
        },this);
        
        if (promises.length > 0) {
            Deft.Promise.all(promises).then({
                scope: this,
                success: function(results) {
                    var parents = Ext.Array.flatten(results);
                    Ext.Array.each(parents,function(parent){
                        fetched_items[parent.get('ObjectID')] = parent;
                    });
                    this._fetchParentItems(parents,fetched_items,deferred);
                },
                failure: function(error_msg){ deferred.reject(error_msg); }
            });
        } else {
            deferred.resolve(fetched_items);
        }
        return deferred.promise;
    },
    _getAssociationFieldFor:function(child_type,parent_type){
        if ( child_type == "defect" ) {
            if ( parent_type == "testcase" ) {
                return "TestCase";
            }
            return 'Requirement';
        }
        return null;
    },
    _getParentFrom:function(child){
        var type = child.get('_type');
        if ( type == "hierarchicalrequirement" ) {
            var parent = child.get('Parent') || child.get('PortfolioItem');
            child.set('parent',parent);
            return parent;
        }
        
        if ( /portfolio/.test(type) ) {
            var parent = child.get("Parent");
            child.set('parent', parent);
            return parent;
        }
        
        if ( type == "task" ) {
            var parent = child.get("WorkProduct");
            child.set('parent', parent);
            return parent;
        }
        
        if ( type == "defect" ) {
            var parent = child.get("Requirement");
            if ( this.targetType == "TestFolder" || this.targetType == "TestCase") {
                parent = child.get('TestCase');
            }
            child.set('parent', parent);
            return parent;
        }
        
        if ( type == "testfolder" ) {
            var parent = child.get("Parent");
            child.set('parent', parent);
            return parent;
        }
        
        if ( type == "testcase" ) {
            var parent = child.get('TestFolder');
            child.set('parent',parent);
            return parent;
        }
        
        return null;
    },
    _getParentFieldsFor:function(type) {
        if ( type == "hierarchicalrequirement" ) {
            return ['Parent','PortfolioItem'];
        }
        
        if ( /portfolio/.test(type) ) {
            return ['Parent'];
        }
        
        if ( type == "task" ) {
            return ['WorkProduct'];
        }
        
        if ( type == "testfolder" ) {
            return ['Parent'];
        }
        
        if ( type == "testcase" ) {
            return ['TestFolder'];
        }
        
        if ( type == "defect" ) {
            return ['TestCase','Requirement'];
        }
        return null;
    },
    _getChildrenFieldsFor: function(type) {
        if ( type == "hierarchicalrequirement" ) {
            return ['Tasks','Defects','Children'];
        }
        if ( /portfolio/.test(type) ) {
            return ['Children','UserStories'];
        }
        
        if ( type == "task" ) {
            return [];
        }
        
        if ( type == "testfolder" ) {
            return ['Children','TestCases']
        }
        return null;
    },
    _getChildTypesFor: function(type){
        if ( type == "hierarchicalrequirement" ) {
            return ['HierarchicalRequirement','Task'];
        }
        if ( /portfolio/.test(type) ) {
            return ['HierarchicalRequirement','PortfolioItem'];
        }
        if ( type == "testfolder" ) {
            return ['TestFolder','TestCase']
        }
        return null;
    },
    _fetchByArrayOfValues:function(model_name,oids,field_name){
        this.logger.log("_fetchByArrayOfValues (", model_name, ",", oids.length, ",", field_name ,")");
        var deferred = Ext.create('Deft.Deferred');
        var filters = Ext.create('Rally.data.wsapi.Filter',{property:field_name,value:oids[0]});
        
        for ( var i=1;i<oids.length;i++ ) {
            filters = filters.or(Ext.create('Rally.data.wsapi.Filter',{
                property:field_name,
                value:oids[i]
            }));
        }
        
        Ext.create('Rally.data.wsapi.Store', {
            autoLoad: true,
            model: model_name,
            fetch: this._getFetchNames(),
            filters: filters,
            context: {
                project: null
            },
            listeners:  {
                scope: this,
                load: function(store, records, success){
                    if (success) {
                        deferred.resolve(records);
                    } else {
                        deferred.reject('Error loading ' + model_name + ' items');
                    }
               }
           }
        });
        return deferred.promise;
    },
    _fetchItemsByOIDArray:function(model_name,oids){
        this.logger.log("_fetchItemsByOIDArray (", oids.length, ")");
        var deferred = Ext.create('Deft.Deferred');
        var filters = Ext.create('Rally.data.wsapi.Filter',{property:'ObjectID',value:oids[0]});
        
        for ( var i=1;i<oids.length;i++ ) {
            filters = filters.or(Ext.create('Rally.data.wsapi.Filter',{
                property:'ObjectID',
                value:oids[i]
            }));
        }
        
        Ext.create('Rally.data.wsapi.Store', {
            autoLoad: true,
            model: model_name,
            fetch: this._getFetchNames(),
            filters: filters,
            context: {
                project: null
            },
            listeners:  {
                scope: this,
                load: function(store, records, success){
                    if (success) {
                        deferred.resolve(records);
                    } else {
                        deferred.reject('Error loading ' + model_name + ' items');
                    }
               }
           }
        });
        return deferred.promise;
    },
    _doColumnCalculations:function(ordered_items){
        var calculated_items = ordered_items;
        Ext.Array.each(this.columns,function(column){
            if ( column.calculator && column.dataIndex ) {
                calculated_items = Rally.technicalservices.util.TreeBuilding.rollup({
                    root_items: ordered_items,
                    field_name: column.dataIndex,
                    leaves_only: column.leaves_only,
                    calculator: column.calculator
                });
            }
        });
        return calculated_items;
    },

    _makeStoreAndShowGrid: function(ordered_items){
        this.logger.log('_makeStoreAndShowGrid',ordered_items);
        if ( ordered_items.length == 0 ) {
            this.add({
                xtype:'container',
                margin: 15,
                html: 'No data found'
            });
        } else {
            var model_config = {
                extend: 'TSTreeModel',
                fields: this._getFetchNames()
            };
            Ext.define('TSTreeModelWithAdditions', model_config);
            
            var tree_store = Ext.create('Ext.data.TreeStore',{
                model: TSTreeModelWithAdditions,
                root: {
                    expanded: false,
                    children: ordered_items
                }
            });
            
            var tree = this.add({
                xtype:'treepanel',
                store: tree_store,
                cls: 'rally-grid',
                rootVisible: false,
                enableColumnMove: false,
                enableColumnResize: false,
                sortableColumns: false,
                rowLines: true,
                height: this.height,
                columns: this.columns
            });
        }

        this.fireEvent('aftertree',this,tree);
    },
    _fetchPortfolioNames: function(){
        var deferred = Ext.create('Deft.Deferred');
        
        Ext.create('Rally.data.wsapi.Store', {
            autoLoad: true,
            model: 'TypeDefinition',
            sorters: [{
              property: 'Ordinal',
              direction: 'ASC'
            }],
            filters: [{
              property: 'Parent.Name',
              operator: '=',
              value: 'Portfolio Item'
            }, {
              property: 'Creatable',
              operator: '=',
              value: true
            }],
            listeners:  {
                scope: this,
                load: function(store, records, success){
                    if (success) {
                        var pi_model_names = _.map(records, function (rec) { return rec.get('TypePath'); });
                        deferred.resolve(pi_model_names);
                    } else {
                        deferred.reject('Error loading portofolio item names.');
                    }
               }
           }
        });
        return deferred.promise;
    },
    _getFetchNames: function() {
        var base_field_names = ['ObjectID','_type','Name'];
        var parent_field_names = ['Parent','PortfolioItem','Requirement','WorkProduct','TestFolder','TestCase'];
        var children_field_names = ['Children','Tasks','UserStories','TestCases'];
        
        var field_names = Ext.Array.merge(base_field_names,children_field_names);
        field_names = Ext.Array.merge(field_names,parent_field_names);
        
        Ext.Array.each(this.columns, function(column){
            field_names = Ext.Array.merge(field_names,[column.dataIndex]);
            if ( column.otherFields ) {
                field_names = Ext.Array.merge(field_names,column.otherFields);
            }
        });
        
        return field_names;
    }
});

Ext.define('Rally.technicalservices.ProgressBarTemplate', {
    requires: [],
    extend: 'Ext.XTemplate',

    config: {
        /**
         * @cfg {String} width define a width if necessary to fit where it's being used
         */
        width: '100%',
        /**
         * @cfg {String} height define a height if necessary to fit where it's being used
         */
        height: '20px',
        /**
         * @cfg {String} numeratorField will divide numeratorField value / denominatorField value to 
         * get percent done
         */
        numeratorField: 'percentDone',
        /**
         * @cfg {String} denominatorField will divide numeratorField value / denominatorField value to 
         * get percent done
         */
        denominatorField: 'percentDone',
        /**
         * 
         * @return {Boolean} opposite true if the numerator is remaining instead of done
         */
        opposite: false,
        /**
         * @cfg {Function} showDangerNotificationFn A function that should return true to show a triangle in the top right to denote something is missing.
         * Defaults to:
         *      function(){ return false; }
         */
        showDangerNotificationFn: function() {
            return false;
        },

        /**
         * @cfg {Function} (required)
         * A function that returns the color for the percent done bar in hex
         */
        calculateColorFn: function(recordData) {            
            var numerator = recordData[this.config.numeratorField] || 0;
            var denominator = recordData[this.config.denominatorField] || 0;
            
            var percentDone = 0;
            
            if ( denominator > 0 ) {
                percentDone = numerator / denominator;
            }
                
            var color = '#9cf';
//            var start_date = recordData['PlannedStartDate'] ;
//            if ( start_date === null ) { 
//                start_date = new Date();
//            }
//            var end_date = recordData['PlannedEndDate'];
//            
//            if ( end_date !== null ) {
//                var color = Rally.util.HealthColorCalculator.calculateHealthColor({
//                    startDate: start_date,
//                    endDate: end_date,
//                    asOfDate: new Date(),
//                    percentComplete: percentDone
//                }).hex;
//            }
            
            return color;
        },

        /**
         * @cfg {Boolean} (optional)
         * A boolean that indicates whether the progress bar is clickable
         */
        isClickable: false,

        /**
         * @cfg {Boolean} If the percent done is 0%, do not show the bar at all
         */
        showOnlyIfInProgress: false,

        /**
         * @cfg {Function}
         * A function that returns the text to show in the progress bar.
         * Defaults to a function that returns the percentage complete.
         */
        generateLabelTextFn: function (recordData) {
            return this.calculatePercent(recordData) + '%';
        }
    },

    constructor: function(config) {
        this.initConfig(config);
        config = this.config;
        var templateConfig = [
            '<tpl if="this.shouldShowPercentDone(values)">',
                '<div class="progress-bar-container field-{[this.getDenominatorField()]} {[this.getClickableClass()]} {[this.getContainerClass(values)]}" style="{[this.getDimensionStyle()]}">',
                    '<div class="progress-bar" style="background-color: {[this.calculateColor(values)]}; width: {[this.calculateWidth(values)]}; "></div>',
                    '<tpl if="this.showDangerNotification(values)">',
                        '<div class="progress-bar-danger-notification"></div>',
                    '</tpl>',
                    '<div class="progress-bar-label">',
                        '{[this.generateLabelText(values)]}',
                    '</div>',
                '</div>',
            '</tpl>',
            {
                shouldShowPercentDone: function(recordData) {
                    return true;
                },
                getContainerClass: function(recordData) {
                    if (recordData && recordData.FormattedID) {
                        return recordData.FormattedID + '-' + config.denominatorField;
                    }
                    return '';
                },
                getClickableClass: function(){
                    return config.isClickable ? 'clickable' : '';
                },
                getDimensionStyle: function(){
                    return 'width: ' + config.width + '; height: ' + config.height + '; line-height: ' + config.height;
                },
                calculateWidth: function (recordData) {
                    var percentDone = this.calculatePercent(recordData);
                    return percentDone > 100 ? '100%' : percentDone + '%';
                },
                calculatePercent: function (recordData) {
                    var numerator = recordData[config.numeratorField] || 0;
                    var denominator = recordData[config.denominatorField] || 0;
                    
                    var percentDone = 0;
                    if ( denominator > 0 ) {
                        percentDone = numerator / denominator;
                    }
                    if ( config.opposite ) {
                        percentDone = 1-percentDone;
                    }
                    return Math.round(percentDone * 100);
                },
                generateLabelText: config.generateLabelTextFn,
                calculateColor: config.calculateColorFn,
                showDangerNotification: config.showDangerNotificationFn
            }];

        return this.callParent(templateConfig);

    }
});
Ext.define('TSTreeModel',{
    extend: 'Ext.data.Model',
    fields: [
        { name: 'FormattedID', type: 'String' },
        { name: 'Name', type:'String' },
        { name: '_ref', type:'String' },
        { name: '_type', type:'String' }
    ]
});
Ext.define('CustomApp', {
    extend: 'Rally.app.App',
    componentCls: 'app',
    logger: new Rally.technicalservices.Logger(),
    autoScroll: false,
    kanbanFieldName: 'c_KanbanState',
    kanbanStates: [],
    items: [
        {xtype:'container',itemId:'selector_box', layout: {type:'hbox'},  margin: 5, height: 50},
        {xtype:'container',itemId:'display_box'},
        {xtype:'tsinfolink', height: 10, informationHtml: 'Progress is calculated as (estimate-todo) as a percentage of estimate' }
    ],
    field_names: ['ObjectID','FormattedID','Name','Parent','PortfolioItem'],

    launch: function() {
        this._fetchModels().then({
            scope: this,
            success:function(models){
                this.models = models;
                var story_model = models['hierarchicalrequirement'];
                var kanban_state_field = story_model.getField(this.kanbanFieldName);
                this.kanbanStates = [];
                kanban_state_field.getAllowedValueStore().load({
                    fetch: ['StringValue'],
                    scope: this,
                    callback: function(values) {
                        Ext.Array.each(values, function(value) {
                            this.kanbanStates.push(value.get('StringValue'));
                        },this);
                        //
                        this._addSelectors(this.down('#selector_box'));
                    }
                });
                
            },
            failure: function(error_msg){
                alert(error_msg);
                this.setLoading(false);
            }
        });
    },
    _getAvailableTreeHeight: function() {
        var body_height = this.getHeight() || Ext.getBody().getHeight();
        this.logger.log("Body height: ", body_height);
        var available_height = body_height - 100;
        this.logger.log("Returning height: ", available_height);
        return available_height;
    },
    _addTree: function() {
        var container = this.down('#display_box');
        container.removeAll();
        
        if ( !this.target_query || this.target_query.toString() == "(Iteration = null)" || this.target_query.toString() == "(Release = null)" ) {
            this.logger.log(" Waiting for timebox to be selected" );
            this.setLoading(false);
        } else {
            this.logger.log(" Using filter/query: ", this.target_query.toString() );
            
            container.add({
                xtype:'insideouttree',
                cls: 'rally-grid',
                columns: this._getColumns(),
                targetType: this.target_type || "UserStory",
                targetQuery: this.target_query,
                height: this._getAvailableTreeHeight(),
                maxHeight: this._getAvailableTreeHeight(),
                listeners: {
                    scope:this,
                    afterrender:function(){
                        this.setLoading("Loading tree...");
                    },
                    afterloadtargets:function() {
                        this.setLoading('Finding relatives...');
                    },
                    afterload:function(){
                        this.setLoading('Building tree...');
                    },
                    aftertree:function(){
                        this.setLoading(false);
                    }
                }
            });
        }
    },
    _addSelectors: function(container){
        var model_names = Ext.Object.getKeys(this.models);
        var me = this;
        this._addReleaseBox(container);
                /**
         * So, the 'change' event when you try to use type-ahead in the
         * field picker and we don't want that to redraw the tree.  But
         * we want the 'change' event because it is fired when we try to
         * remember fields that were selected in the past and we definitely 
         * want that value.
         */
        this.react_to_change = true;
        
        var field_picker = container.add({
            xtype:'rallyfieldpicker',
            autoExpand:true,
            margin: 10,
            alwaysExpanded: false,
            fieldLabel: 'Add Columns:',
            labelWidth: 75,
            modelTypes:model_names,
            useColumnHeaderLabels: true,
            stateful: true,
            stateId: 'rally.techservices.tree.insideout.fields',
            stateEvents:['blur','selectionchange'],
            getState: function() {
                var value_array = [];
                Ext.Array.each(this.getValue(), function(value){
                    value_array.push(value.get('name'));
                });
                
                return this.addPropertyToState({},'value',value_array);
            },
            listeners: {
                scope: this,
                blur: function(picker){
                    this.logger.log("BLUR fields", picker.isExpanded);
                    var additional_columns = picker.getValue() || [];
                    this.logger.log("Changing picker from ", this.additional_columns, " to ", additional_columns);
                    if ( this._fieldArraysAreDifferent(this.additional_columns,additional_columns) ) {
                        this.additional_columns = additional_columns;
                        picker.collapse();
                        this._addTree();
                    }
                },
                change: function(picker) {
                    this.logger.log('CHANGE fields');
                    this.additional_columns = picker.getValue() || [];
                    picker.collapse();
                    if ( this.additional_columns.length > 0 && this.react_to_change ) {
                        this.react_to_change = false;
                        this._addTree();
                    }
                },
                selectionchange: function() {
                    this.logger.log('SELECTION CHANGE fields');
                },
                datachanged: function() {
                    this.logger.log('DATA CHANGED fields');
                }
            }
        });
        field_picker.on('expand',function(picker){picker.collapse();},this,{single:true});
        
        
    },
    _addReleaseBox: function(container) {
        container.add({
            xtype:'rallyreleasecombobox',
            itemId:'timebox',
            fieldLabel:'Release:',
            labelWidth: 55,
            width: 250,
            margin: 10,
            allowBlank: false,
            stateful: false,
            stateId:'rally.techservices.target.release',
            stateEvents:['change'],
            listeners:{
                scope: this,
                change: function(release_box){
                    if ( this.target_query != release_box.getQueryFromSelected() ) {
                        this.target_query = release_box.getQueryFromSelected();
                        this._addTree();
                    }
                }
            }
        });
    },
    _getColumns: function() {
        var me = this;
        var name_renderer = function(value,meta_data,record) {
            return me._nameRenderer(value,meta_data,record);
        };
        
        var magic_renderer = function(field,value,meta_data,record){
            return me._magicRenderer(field,value,meta_data,record);
        }
        
        var columns = [
            {
                xtype: 'treecolumn',
                text: 'Item',
                dataIndex: 'Name',
                itemId: 'tree_column',
                renderer: name_renderer,
                width: 400,
                menuDisabled: true,
                otherFields: ['FormattedID','ObjectID']
            },
            {
                text:'Project',
                dataIndex:'Project',
                menuDisabled: true,
                renderer:function(value,meta_data,record){
                    return me._magicRenderer({name:'Project'},value,meta_data,record) || "";
                }
            },
            {
                text:'Release',
                dataIndex:'Release',
                menuDisabled: true,
                renderer:function(value,meta_data,record){
                    return me._magicRenderer({name:'Release'},value,meta_data,record) || "";
                }
            },
            { 
                text: "Planned Start",
                dataIndex: "PlannedStartDate",
                menuDisabled: true,
                renderer:function(value,meta_data,record){
                    return me._magicRenderer({name:'PlannedStartDate'},value,meta_data,record) || "";
                }
            },
            { 
                text: "Planned End",
                dataIndex: "PlannedEndDate",
                menuDisabled: true,
                renderer:function(value,meta_data,record){
                    return me._magicRenderer({name:'PlannedEndDate'},value,meta_data,record) || "";
                }            
            },
            {
                text: 'Estimate',
                dataIndex: 'Estimate',
                menuDisabled: true,
                calculator: function(item) {
                    var orig_value = item.get('Estimate') || 0;
                    return orig_value;
                }
            },
            {
                text: 'ToDo',
                dataIndex: 'ToDo',
                menuDisabled: true,
                calculator: function(item) {
                    var orig_value = item.get('ToDo') || 0;
                    return orig_value;
                }
            },
            {
                text: 'Story State',
                menuDisabled: true,
                hidden: true,
                dataIndex: 'ScheduleState'
            },
            {
                text: 'Story Kanban State',
                hidden: true,
                menuDisabled: true,
                dataIndex: me.kanbanFieldName
            },
            {
                text: 'Story Count',
                dataIndex: '__story_count',
                hidden: true,
                menuDisabled: true,
                leavesOnly: true,
                calculator: function(item) {
                    if ( item.get('_type') == 'hierarchicalrequirement' && item.get('DirectChildrenCount') == 0 ) {
                        return 1;
                    }
                    return 0;
                },
                otherFields: ['DirectChildrenCount']
            },
            {
                text: 'Progress',
                dataIndex: 'Progress',
                menuDisabled: true,
                renderer: function(value,meta_data,item) {
                    return Ext.create('Rally.technicalservices.ProgressBarTemplate',{
                        numeratorField: 'ToDo',
                        denominatorField: 'Estimate',
                        opposite: true
                    }).apply(item.getData());
                }
            },
            {
                text: 'Stories Dev Complete',
                dataIndex: '__story_dev_complete_count',
                menuDisabled: true,
                leavesOnly: true,
                calculator: function(item) {
                    if ( item.get('_type') == 'hierarchicalrequirement' && item.get('DirectChildrenCount') == 0 ) {
                        if ( Ext.Array.indexOf(me.kanbanStates,item.get(me.kanbanFieldName)) >= Ext.Array.indexOf(me.kanbanStates, "Ready for Test") ) {
                            return 1;
                        }
                    }
                    return 0;
                },
                otherFields: ['DirectChildrenCount',me.kanbanFieldName],
                renderer: function(value,meta_data,item) {
                    return Ext.create('Rally.technicalservices.ProgressBarTemplate',{
                        numeratorField: '__story_dev_complete_count',
                        denominatorField: '__story_count'
                    }).apply(item.getData());
                }
            },
            {
                text: 'Stories Test Complete',
                dataIndex: '__story_test_complete_count',
                menuDisabled: true,
                leavesOnly: true,
                calculator: function(item) {
                    if ( item.get('_type') == 'hierarchicalrequirement' && item.get('DirectChildrenCount') == 0 ) {
                        if ( Ext.Array.indexOf(me.kanbanStates,item.get(me.kanbanFieldName)) >= Ext.Array.indexOf(me.kanbanStates, "Complete") ) {
                            return 1;
                        }
                    }
                    return 0;
                },
                otherFields: ['DirectChildrenCount',me.kanbanFieldName],
                renderer: function(value,meta_data,item) {
                    return Ext.create('Rally.technicalservices.ProgressBarTemplate',{
                        numeratorField: '__story_test_complete_count',
                        denominatorField: '__story_count'
                    }).apply(item.getData());
                }
            },
            {
                text: 'Stories Accepted',
                dataIndex: '__story_accepted_count',
                menuDisabled: true,
                leavesOnly: true,
                calculator: function(item) {
                    if ( item.get('_type') == 'hierarchicalrequirement' && item.get('DirectChildrenCount') == 0 ) {
                        if ( item.get('ScheduleState') == "Accepted" ) {
                            return 1;
                        }
                    }
                    return 0;
                },
                otherFields: ['DirectChildrenCount','ScheduleState'],
                renderer: function(value,meta_data,item) {
                    return Ext.create('Rally.technicalservices.ProgressBarTemplate',{
                        numeratorField: '__story_accepted_count',
                        denominatorField: '__story_count'
                    }).apply(item.getData());
                }
            }
        ];
        
        var base_column_names = [];
        Ext.Array.each(columns, function(column) {
            base_column_names.push(column.dataIndex);
        });
        
        if ( this.additional_columns ) {
            Ext.Array.each(this.additional_columns, function(field) {
                if ( Ext.Array.indexOf(base_column_names,field.get('name')) == -1 ) {
                    columns.push({
                        text:field.get('displayName').replace(/\(.*\)/,""),
                        dataIndex:field.get('name'),
                        menuDisabled: true,
                        renderer:function(value,meta_data,record){
                            return me._magicRenderer(field,value,meta_data,record) || "";
                        }
                    });
                }
            });
        }
        return columns;
    },
    _magicRenderer: function(field,value,meta_data,record){
        var field_name = field.name || field.get('name');
        var record_type = record.get('_type');
        var model = this.models[record_type];
        // will fail fi field is not on the record
        // (e.g., we pick accepted date, by are also showing features
        try {
            var template = Rally.ui.renderer.RendererFactory.getRenderTemplate(model.getField(field_name)) || "";
            return template.apply(record.data);
        } catch(e) {
            return ".";
        }
    },
    _nameRenderer: function(value,meta_data,record) {
        var display_value = record.get('Name');
        if ( record.get('FormattedID') ) {
            var link_text = record.get('FormattedID') + ": " + value;
            var url = Rally.nav.Manager.getDetailUrl( record );
            display_value = "<a target='_blank' href='" + url + "'>" + link_text + "</a>";
        }
        return display_value;
    },
    _fetchModels: function(){
        var deferred = Ext.create('Deft.Deferred');
        this._fetchPortfolioNames().then({
            scope: this,
            success:function(pi_names){
                var model_names = Ext.Array.merge(['defect','hierarchicalrequirement','task'],pi_names);
                console.log("model_names",model_names);
                Rally.data.ModelFactory.getModels({
                    types: model_names,
                    success: function(model_hash) {
                        deferred.resolve(model_hash);
                    },
                    failure: deferred.reject
                });
            },
            failure:deferred.reject
        });
        return deferred.promise;
    },
    _fetchPortfolioNames: function(){
        var deferred = Ext.create('Deft.Deferred');
        
        Ext.create('Rally.data.wsapi.Store', {
            autoLoad: true,
            model: 'TypeDefinition',
            sorters: [{
              property: 'Ordinal',
              direction: 'ASC'
            }],
            filters: [{
              property: 'Parent.Name',
              operator: '=',
              value: 'Portfolio Item'
            }, {
              property: 'Creatable',
              operator: '=',
              value: true
            }],
            listeners:  {
                scope: this,
                load: function(store, records, success){
                    if (success) {
                        var pi_model_names = _.map(records, function (rec) { return Ext.util.Format.lowercase(rec.get('TypePath')); });
                        deferred.resolve(pi_model_names);
                    } else {
                        deferred.reject('Error loading portofolio item names.');
                    }
               }
           }
        });
        return deferred.promise;
    },
    _fieldArraysAreDifferent:function(fields_1,fields_2) {
        var changed = false;
        Ext.Array.each(fields_1, function(field_1){
            var in_fields_2 = false;
            Ext.Array.each(fields_2,function(field_2){
                if ( field_2.get('name') == field_1.get('name') ) {
                    in_fields_2 = true;
                }
            });
            if ( ! in_fields_2 ) { changed=true; }
        });
        
        Ext.Array.each(fields_2, function(field_2){
            var in_fields_1 = false;
            Ext.Array.each(fields_1,function(field_1){
                if ( field_1.get('name') == field_2.get('name')) {
                    in_fields_1 = true;
                }
            });
            if ( ! in_fields_1 ) { changed=true; }
        });
        
        return changed;
    }

});
            
               Rally.launchApp('CustomApp', {
                   name: 'Progress by Hours'
               });
        });
    </script>
    
    <style type="text/css">

.app {
}
.tsinfolink {
    position:absolute;
    right:0px;
    width: 14px;
    height: 14px;
    border-radius: 7px;
    text-align: center;
    color: white;
    background: #C0C0C0;
    border-style: solid;
    border-width: 1px;
    margin-top: 25px;
    margin-right: 5px;
    cursor: pointer;
}

.x-tree-panel.rally-grid .x-grid-body .x-grid-row .x-grid-cell .x-grid-cell-inner
{
    padding-top: 2px;
    padding-bottom: 2px;
    line-height: 25px;
}
    </style>

</head>
<body></body>
</html>